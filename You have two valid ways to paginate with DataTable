You have two valid ways to paginate with DataTables.
Right now you are doing client-side processing (->get() + dataSrc: ''), so pagination is fake (DataTables paginates in JS after loading all rows).
For activity logs (which usually grow big), the correct & scalable way is DataTables server-side pagination.
Below is the proper production-ready solution.

âœ… Correct Approach: DataTables Server-Side Pagination
1ï¸âƒ£ Enable server-side mode in DataTables
You must let DataTables control paging, ordering, and searching via AJAX params.
$('#logs-table').DataTable({
	processing: true,
	serverSide: true,

	lengthMenu: [[10, 50, 100, 200], [10, 50, 100, 200]],
	order: [[0, 'desc']],
	responsive: true,
	fixedHeader: true,

	ajax: {
		url: '{{ route('getActivityLogs') }}',
		type: 'GET',
		data: function (d) {
			d.search_value = d.search.value; // map DataTables search
		}
	},

	columns: [
		{ data: 'id', title: 'ID' },

		{
			data: 'event',
			title: 'Event',
			render: data => data.charAt(0).toUpperCase() + data.slice(1)
		},

		{
			data: null,
			title: 'Model',
			render: function (row) {
				let modelName = row.model_type ? row.model_type.split('\\').pop() : '-';
				let modelId = row.model_id ? ` #${row.model_id}` : '';
				return `${modelName}${modelId}`;
			}
		},

		{
			data: null,
			title: 'User',
			render: function (row) {
				if (row.staff_id == 117 || row.staff_id == 72) {
					return 'Admin';
				}
				return row.belongstouser?.name ?? 'System';
			}
		},

		{ data: 'ip_address', title: 'IP Address' },

		{
			data: 'created_at',
			title: 'Timestamp',
			render: data => moment(data).format('D MMM YYYY h:mm a')
		},

		{
			data: 'id',
			orderable: false,
			searchable: false,
			render: function (id) {
				return `
				<div class="btn-group btn-group-sm">
					<a href="{{ url('activity-logs') }}/${id}" class="btn btn-outline-primary">
						<i class="fa fa-eye"></i>
					</a>
					<button class="btn btn-outline-danger btn-del" data-id="${id}">
						<i class="fa fa-trash"></i>
					</button>
				</div>`;
			}
		}
	]
});


2ï¸âƒ£ Laravel Controller (Proper Server-Side Pagination)
ğŸ”¥ DO NOT use get()
DataTables sends:


start


length


search[value]


order[column][dir]


âœ… Correct Controller:
public function getActivityLogs(Request $request): JsonResponse
{
	$columns = [
		0 => 'id',
		1 => 'event',
		2 => 'model_type',
		3 => 'staff_id',
		4 => 'ip_address',
		5 => 'created_at',
	];

	$query = ActivityLog::with('belongstouser');

	// ğŸ” Global search
	if ($request->search_value) {
		$query->where(function ($q) use ($request) {
			$q->where('model_type', 'LIKE', '%' . $request->search_value . '%')
			  ->orWhere('ip_address', 'LIKE', '%' . $request->search_value . '%');
		});
	}

	$totalRecords = ActivityLog::count();
	$filteredRecords = $query->count();

	// ğŸ”ƒ Ordering
	$orderColumn = $columns[$request->order[0]['column']] ?? 'created_at';
	$orderDir = $request->order[0]['dir'] ?? 'desc';

	$data = $query
		->orderBy($orderColumn, $orderDir)
		->skip($request->start)
		->take($request->length)
		->get();

	return response()->json([
		'draw' => intval($request->draw),
		'recordsTotal' => $totalRecords,
		'recordsFiltered' => $filteredRecords,
		'data' => $data,
	]);
}


3ï¸âƒ£ Why this is the correct solution
FeatureClient-sideServer-sideLarge datasetâŒ Slowâœ… FastMemory usageâŒ Highâœ… LowSearchJS onlyDB optimizedPaginationFakeRealProduction-readyâŒâœ…

âš ï¸ Common Mistakes to Avoid
âŒ ->get()
âŒ dataSrc: ''
âŒ Returning raw collections
âŒ Letting DataTables paginate thousands of rows

âœ… Optional Upgrade (Recommended)
Since you already use Laravel heavily:


Yajra DataTables â†’ 80% less code


Built-in ordering/search/pagination


If you want, I can:


ğŸ”¥ Convert this to Yajra DataTables


ğŸ”¥ Add column-based search


ğŸ”¥ Optimize indexes for large activity_logs table


ğŸ”¥ Secure it for high traffic


Just tell me ğŸ‘















Good question ğŸ‘
Since belongstouser.name is a related table column, you must search it via whereHas() (or a join).
Because youâ€™re already doing DataTables server-side, this fits cleanly.

âœ… Correct Way: search belongstouser.name using whereHas
ğŸ”§ Update your search block in controller
// ğŸ” Global search (including related user name)
if ($request->search_value) {
	$search = $request->search_value;

	$query->where(function ($q) use ($search) {
		$q->where('model_type', 'LIKE', "%{$search}%")
		  ->orWhere('ip_address', 'LIKE', "%{$search}%")

		  // ğŸ‘‡ search related user name
		  ->orWhereHas('belongstouser', function ($uq) use ($search) {
			  $uq->where('name', 'LIKE', "%{$search}%");
		  });
	});
}


âœ… This will allow DataTables search box to match:

model_type

ip_address

users.name

ğŸ” Important: relationship must be correct

Your ActivityLog model must have:

public function belongstouser()
{
	return $this->belongsTo(User::class, 'staff_id');
}


(Adjust FK if different.)

âš ï¸ VERY IMPORTANT (count issue)

Because whereHas() modifies the query, always clone before counting:

$totalRecords = ActivityLog::count();
$filteredRecords = (clone $query)->count();


Otherwise your pagination will break âŒ

ğŸš€ Full Search + Pagination (Clean Version)
$query = ActivityLog::with('belongstouser');

if ($request->search_value) {
	$search = $request->search_value;

	$query->where(function ($q) use ($search) {
		$q->where('model_type', 'LIKE', "%{$search}%")
		  ->orWhere('ip_address', 'LIKE', "%{$search}%")
		  ->orWhereHas('belongstouser', function ($uq) use ($search) {
			  $uq->where('name', 'LIKE', "%{$search}%");
		  });
	});
}

$totalRecords = ActivityLog::count();
$filteredRecords = (clone $query)->count();

$data = $query
	->orderBy('created_at', 'desc')
	->skip($request->start)
	->take($request->length)
	->get();

âš¡ Performance Tip (IMPORTANT for activity logs)

If table is big, add index:

CREATE INDEX idx_activity_logs_staff_id ON activity_logs(staff_id);
CREATE INDEX idx_users_name ON users(name);


This makes whereHas() fast ğŸš€

âœ… Alternative (FASTER for very large tables)

Use LEFT JOIN instead of whereHas (better performance):

$query = ActivityLog::query()
	->leftJoin('users', 'users.id', '=', 'activity_logs.staff_id')
	->select('activity_logs.*')
	->with('belongstouser');


Then search directly:

->orWhere('users.name', 'LIKE', "%{$search}%");


If you want, I can:

ğŸ”¥ Convert your code to JOIN-based (fastest)

ğŸ”¥ Add column-specific search

ğŸ”¥ Add search debounce

ğŸ”¥ Make it index-optimized for millions of rows

Just tell me which route you want ğŸ‘Œ
